/* Generated by JTB 1.4.9 */
package parser.visitor;

import parser.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "VoidArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <A> - The user argument type
 */
public class DepthFirstVoidArguVisitor<A> implements IVoidArguVisitor<A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeChoice n, final A argu) {
    n.choice.accept(this, argu);
    return;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeList n, final A argu) {
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      e.next().accept(this, argu);
    }
    return;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeListOptional n, final A argu) {
    if (n.present()) {
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        e.next().accept(this, argu);
        }
      return;
    } else
      return;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeOptional n, final A argu) {
    if (n.present()) {
      n.node.accept(this, argu);
      return;
    } else
      return;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeSequence n, final A argu) {
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      e.next().accept(this, argu);
    }
    return;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeTCF n, @SuppressWarnings("unused") final A argu) {
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link Start} node, whose children are the following :
   * <p>
   * f0 -> InputSection()<br>
   * f1 -> RequiredSection()<br>
   * f2 -> OutputSection()<br>
   * f3 -> <EOF><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final Start n, final A argu) {
    // f0 -> InputSection()
    final InputSection n0 = n.f0;
    n0.accept(this, argu);
    // f1 -> RequiredSection()
    final RequiredSection n1 = n.f1;
    n1.accept(this, argu);
    // f2 -> OutputSection()
    final OutputSection n2 = n.f2;
    n2.accept(this, argu);
    // f3 -> <EOF>
    final NodeToken n3 = n.f3;
    n3.accept(this, argu);
  }

  /**
   * Visits a {@link InputSection} node, whose children are the following :
   * <p>
   * f0 -> <INPUT><br>
   * f1 -> <EOL><br>
   * f2 -> ( InputVarDef() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final InputSection n, final A argu) {
    // f0 -> <INPUT>
    final NodeToken n0 = n.f0;
    n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    n1.accept(this, argu);
    // f2 -> ( InputVarDef() )*
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode nloeai = n2.elementAt(i);
        nloeai.accept(this, argu);
      }
    }
  }

  /**
   * Visits a {@link RequiredSection} node, whose children are the following :
   * <p>
   * f0 -> <REQUIRED><br>
   * f1 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final RequiredSection n, final A argu) {
    // f0 -> <REQUIRED>
    final NodeToken n0 = n.f0;
    n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    n1.accept(this, argu);
  }

  /**
   * Visits a {@link OutputSection} node, whose children are the following :
   * <p>
   * f0 -> <OUTPUT><br>
   * f1 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final OutputSection n, final A argu) {
    // f0 -> <OUTPUT>
    final NodeToken n0 = n.f0;
    n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    n1.accept(this, argu);
  }

  /**
   * Visits a {@link InputVarDef} node, whose children are the following :
   * <p>
   * f0 -> <IDENTIFIER><br>
   * f1 -> ":"<br>
   * f2 -> [ TypeDef() ]<br>
   * f3 -> [ RangeDef() ]<br>
   * f4 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final InputVarDef n, final A argu) {
    // f0 -> <IDENTIFIER>
    final NodeToken n0 = n.f0;
    n0.accept(this, argu);
    // f1 -> ":"
    final NodeToken n1 = n.f1;
    n1.accept(this, argu);
    // f2 -> [ TypeDef() ]
    final NodeOptional n2 = n.f2;
    if (n2.present()) {
      n2.accept(this, argu);
    }
    // f3 -> [ RangeDef() ]
    final NodeOptional n3 = n.f3;
    if (n3.present()) {
      n3.accept(this, argu);
    }
    // f4 -> <EOL>
    final NodeToken n4 = n.f4;
    n4.accept(this, argu);
  }

  /**
   * Visits a {@link TypeDef} node, whose children are the following :
   * <p>
   * f0 -> ( %0 <INT><br>
   * .. .. | %1 <REAL><br>
   * .. .. | %2 <BOOL><br>
   * .. .. | %3 <CHAR><br>
   * .. .. | %4 <STRING> )<br>
   * f1 -> [ #0 "["<br>
   * .. .. . #1 [ $0 Expression() $1 "~" $2 Expression() ]<br>
   * .. .. . #2 "]" ]<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final TypeDef n, final A argu) {
    // f0 -> ( %0 <INT>
    // .. .. | %1 <REAL>
    // .. .. | %2 <BOOL>
    // .. .. | %3 <CHAR>
    // .. .. | %4 <STRING> )
    final NodeChoice n0 = n.f0;
    final NodeChoice nch = n0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 <INT>
        ich.accept(this, argu);
        break;
      case 1:
        // %1 <REAL>
        ich.accept(this, argu);
        break;
      case 2:
        // %2 <BOOL>
        ich.accept(this, argu);
        break;
      case 3:
        // %3 <CHAR>
        ich.accept(this, argu);
        break;
      case 4:
        // %4 <STRING>
        ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    // f1 -> [ #0 "["
    // .. .. . #1 [ $0 Expression() $1 "~" $2 Expression() ]
    // .. .. . #2 "]" ]
    final NodeOptional n1 = n.f1;
    if (n1.present()) {
      final NodeSequence seq = (NodeSequence) n1.node;
      // #0 "["
      final INode seq1 = seq.elementAt(0);
      seq1.accept(this, argu);
      // #1 [ $0 Expression() $1 "~" $2 Expression() ]
      final INode seq2 = seq.elementAt(1);
      final NodeOptional opt = (NodeOptional) seq2;
      if (opt.present()) {
        final NodeSequence seq3 = (NodeSequence) opt.node;
        // $0 Expression()
        final INode seq4 = seq3.elementAt(0);
        seq4.accept(this, argu);
        // $1 "~"
        final INode seq5 = seq3.elementAt(1);
        seq5.accept(this, argu);
        // $2 Expression()
        final INode seq6 = seq3.elementAt(2);
        seq6.accept(this, argu);
      }
      // #2 "]"
      final INode seq7 = seq.elementAt(2);
      seq7.accept(this, argu);
    }
  }

  /**
   * Visits a {@link RangeDef} node, whose children are the following :
   * <p>
   * f0 -> ( %0 "("<br>
   * .. .. | %1 "[" )<br>
   * f1 -> Expression()<br>
   * f2 -> ","<br>
   * f3 -> Expression()<br>
   * f4 -> ( %0 ")"<br>
   * .. .. | %1 "]" )<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final RangeDef n, final A argu) {
    // f0 -> ( %0 "("
    // .. .. | %1 "[" )
    final NodeChoice n0 = n.f0;
    final NodeChoice nch = n0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 "("
        ich.accept(this, argu);
        break;
      case 1:
        // %1 "["
        ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    // f1 -> Expression()
    final Expression n1 = n.f1;
    n1.accept(this, argu);
    // f2 -> ","
    final NodeToken n2 = n.f2;
    n2.accept(this, argu);
    // f3 -> Expression()
    final Expression n3 = n.f3;
    n3.accept(this, argu);
    // f4 -> ( %0 ")"
    // .. .. | %1 "]" )
    final NodeChoice n4 = n.f4;
    final NodeChoice nch1 = n4;
    final INode ich1 = nch1.choice;
    switch (nch1.which) {
      case 0:
        // %0 ")"
        ich1.accept(this, argu);
        break;
      case 1:
        // %1 "]"
        ich1.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
  }

  /**
   * Visits a {@link Expression} node, whose child is the following :
   * <p>
   * f0 -> . %0 <IDENTIFIER><br>
   * .. .. | %1 <LITERAL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   */
  @Override
  public void visit(final Expression n, final A argu) {
    // f0 -> . %0 <IDENTIFIER>
    // .. .. | %1 <LITERAL>
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 <IDENTIFIER>
        ich.accept(this, argu);
        break;
      case 1:
        // %1 <LITERAL>
        ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
  }

}
