/* Generated by JTB 1.4.9 */
package parser.visitor;

import parser.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "RetArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The user return information type
 * @param <A> - The user argument type
 */
public class DepthFirstRetArguVisitor<R, A> implements IRetArguVisitor<R, A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeChoice n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    final R nRes = n.choice.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeList n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeListOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this, argu);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      final R nRes = n.node.accept(this, argu);
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeSequence n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeTCF n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link Start} node, whose children are the following :
   * <p>
   * f0 -> InputSection()<br>
   * f1 -> RequiredSection()<br>
   * f2 -> OutputSection()<br>
   * f3 -> <EOF><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Start n, final A argu) {
    R nRes = null;
    // f0 -> InputSection()
    final InputSection n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> RequiredSection()
    final RequiredSection n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> OutputSection()
    final OutputSection n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> <EOF>
    final NodeToken n3 = n.f3;
    nRes = n3.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link InputSection} node, whose children are the following :
   * <p>
   * f0 -> <INPUT><br>
   * f1 -> <EOL><br>
   * f2 -> ( InputVarDef() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final InputSection n, final A argu) {
    R nRes = null;
    // f0 -> <INPUT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> ( InputVarDef() )*
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode nloeai = n2.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link RequiredSection} node, whose children are the following :
   * <p>
   * f0 -> <REQUIRED><br>
   * f1 -> <EOL><br>
   * f2 -> ( RequiredCond() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final RequiredSection n, final A argu) {
    R nRes = null;
    // f0 -> <REQUIRED>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> ( RequiredCond() )*
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode nloeai = n2.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link OutputSection} node, whose children are the following :
   * <p>
   * f0 -> <OUTPUT><br>
   * f1 -> <EOL><br>
   * f2 -> ( OutputExp() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final OutputSection n, final A argu) {
    R nRes = null;
    // f0 -> <OUTPUT>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> ( OutputExp() )*
    final NodeListOptional n2 = n.f2;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode nloeai = n2.elementAt(i);
        nRes = nloeai.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link InputVarDef} node, whose children are the following :
   * <p>
   * f0 -> <IDENTIFIER><br>
   * f1 -> [ TypeDef() ]<br>
   * f2 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final InputVarDef n, final A argu) {
    R nRes = null;
    // f0 -> <IDENTIFIER>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> [ TypeDef() ]
    final NodeOptional n1 = n.f1;
    if (n1.present()) {
      nRes = n1.accept(this, argu);
    }
    // f2 -> <EOL>
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link RequiredCond} node, whose children are the following :
   * <p>
   * f0 -> ( %0 #0 <IDENTIFIER> #1 TypeDef()<br>
   * .. .. | %1 Expression() )<br>
   * f1 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final RequiredCond n, final A argu) {
    R nRes = null;
    // f0 -> ( %0 #0 <IDENTIFIER> #1 TypeDef()
    // .. .. | %1 Expression() )
    final NodeChoice n0 = n.f0;
    final NodeChoice nch = n0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 #0 <IDENTIFIER> #1 TypeDef()
        final NodeSequence seq = (NodeSequence) ich;
        // #0 <IDENTIFIER>
        final INode seq1 = seq.elementAt(0);
        nRes = seq1.accept(this, argu);
        // #1 TypeDef()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
        break;
      case 1:
        // %1 Expression()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link OutputExp} node, whose children are the following :
   * <p>
   * f0 -> Expression()<br>
   * f1 -> <EOL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final OutputExp n, final A argu) {
    R nRes = null;
    // f0 -> Expression()
    final Expression n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> <EOL>
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link TypeDef} node, whose child is the following :
   * <p>
   * f0 -> . %0 #0 ":"<br>
   * .. .. . .. #1 ( &0 <INT><br>
   * .. .. . .. .. | &1 <REAL><br>
   * .. .. . .. .. | &2 <BOOL><br>
   * .. .. . .. .. | &3 <CHAR><br>
   * .. .. . .. .. | &4 <STRING> )<br>
   * .. .. . .. #2 [ $0 "["<br>
   * .. .. . .. .. . $1 [ ?0 Expression() ?1 "~" ?2 Expression() ]<br>
   * .. .. . .. .. . $2 "]" ]<br>
   * .. .. . .. #3 [ RangeDef() ]<br>
   * .. .. | %1 RangeDef()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final TypeDef n, final A argu) {
    R nRes = null;
    // f0 -> . %0 #0 ":"
    // .. .. . .. #1 ( &0 <INT>
    // .. .. . .. .. | &1 <REAL>
    // .. .. . .. .. | &2 <BOOL>
    // .. .. . .. .. | &3 <CHAR>
    // .. .. . .. .. | &4 <STRING> )
    // .. .. . .. #2 [ $0 "["
    // .. .. . .. .. . $1 [ ?0 Expression() ?1 "~" ?2 Expression() ]
    // .. .. . .. .. . $2 "]" ]
    // .. .. . .. #3 [ RangeDef() ]
    // .. .. | %1 RangeDef()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 #0 ":"
        // .. #1 ( &0 <INT>
        // .. .. | &1 <REAL>
        // .. .. | &2 <BOOL>
        // .. .. | &3 <CHAR>
        // .. .. | &4 <STRING> )
        // .. #2 [ $0 "["
        // .. .. . $1 [ ?0 Expression() ?1 "~" ?2 Expression() ]
        // .. .. . $2 "]" ]
        // .. #3 [ RangeDef() ]
        final NodeSequence seq = (NodeSequence) ich;
        // #0 ":"
        final INode seq1 = seq.elementAt(0);
        nRes = seq1.accept(this, argu);
        // #1 ( &0 <INT>
        // .. | &1 <REAL>
        // .. | &2 <BOOL>
        // .. | &3 <CHAR>
        // .. | &4 <STRING> )
        final INode seq2 = seq.elementAt(1);
        final NodeChoice nch1 = (NodeChoice) seq2;
        final INode ich1 = nch1.choice;
        switch (nch1.which) {
          case 0:
            // &0 <INT>
            nRes = ich1.accept(this, argu);
            break;
          case 1:
            // &1 <REAL>
            nRes = ich1.accept(this, argu);
            break;
          case 2:
            // &2 <BOOL>
            nRes = ich1.accept(this, argu);
            break;
          case 3:
            // &3 <CHAR>
            nRes = ich1.accept(this, argu);
            break;
          case 4:
            // &4 <STRING>
            nRes = ich1.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #2 [ $0 "["
        // .. . $1 [ ?0 Expression() ?1 "~" ?2 Expression() ]
        // .. . $2 "]" ]
        final INode seq3 = seq.elementAt(2);
        final NodeOptional opt = (NodeOptional) seq3;
        if (opt.present()) {
          final NodeSequence seq4 = (NodeSequence) opt.node;
          // $0 "["
          final INode seq5 = seq4.elementAt(0);
          nRes = seq5.accept(this, argu);
          // $1 [ ?0 Expression() ?1 "~" ?2 Expression() ]
          final INode seq6 = seq4.elementAt(1);
          final NodeOptional opt1 = (NodeOptional) seq6;
          if (opt1.present()) {
            final NodeSequence seq7 = (NodeSequence) opt1.node;
            // ?0 Expression()
            final INode seq8 = seq7.elementAt(0);
            nRes = seq8.accept(this, argu);
            // ?1 "~"
            final INode seq9 = seq7.elementAt(1);
            nRes = seq9.accept(this, argu);
            // ?2 Expression()
            final INode seq10 = seq7.elementAt(2);
            nRes = seq10.accept(this, argu);
          }
          // $2 "]"
          final INode seq11 = seq4.elementAt(2);
          nRes = seq11.accept(this, argu);
        }
        // #3 [ RangeDef() ]
        final INode seq12 = seq.elementAt(3);
        final NodeOptional opt2 = (NodeOptional) seq12;
        if (opt2.present()) {
          nRes = opt2.accept(this, argu);
        }
        break;
      case 1:
        // %1 RangeDef()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link RangeDef} node, whose children are the following :
   * <p>
   * f0 -> ( %0 "("<br>
   * .. .. | %1 "[" )<br>
   * f1 -> Expression()<br>
   * f2 -> ","<br>
   * f3 -> Expression()<br>
   * f4 -> ( %0 ")"<br>
   * .. .. | %1 "]" )<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final RangeDef n, final A argu) {
    R nRes = null;
    // f0 -> ( %0 "("
    // .. .. | %1 "[" )
    final NodeChoice n0 = n.f0;
    final NodeChoice nch = n0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 "("
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 "["
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    // f1 -> Expression()
    final Expression n1 = n.f1;
    nRes = n1.accept(this, argu);
    // f2 -> ","
    final NodeToken n2 = n.f2;
    nRes = n2.accept(this, argu);
    // f3 -> Expression()
    final Expression n3 = n.f3;
    nRes = n3.accept(this, argu);
    // f4 -> ( %0 ")"
    // .. .. | %1 "]" )
    final NodeChoice n4 = n.f4;
    final NodeChoice nch1 = n4;
    final INode ich1 = nch1.choice;
    switch (nch1.which) {
      case 0:
        // %0 ")"
        nRes = ich1.accept(this, argu);
        break;
      case 1:
        // %1 "]"
        nRes = ich1.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Expression} node, whose child is the following :
   * <p>
   * f0 -> . %0 <IDENTIFIER><br>
   * .. .. | %1 <LITERAL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Expression n, final A argu) {
    R nRes = null;
    // f0 -> . %0 <IDENTIFIER>
    // .. .. | %1 <LITERAL>
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 <IDENTIFIER>
        nRes = ich.accept(this, argu);
        break;
      case 1:
        // %1 <LITERAL>
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

}
