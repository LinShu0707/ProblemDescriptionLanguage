/* Generated by JTB 1.4.9 */
package parser.visitor;

import parser.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "RetArgu" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The user return information type
 * @param <A> - The user argument type
 */
public class DepthFirstRetArguVisitor<R, A> implements IRetArguVisitor<R, A> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeChoice n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    final R nRes = n.choice.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeList n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeListOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this, argu);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeOptional n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      final R nRes = n.node.accept(this, argu);
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeSequence n, final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this, argu);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeTCF n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link Start} node, whose children are the following :
   * <p>
   * f0 -> Expression()<br>
   * f1 -> ";"<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Start n, final A argu) {
    R nRes = null;
    // f0 -> Expression()
    final Expression n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ";"
    final NodeToken n1 = n.f1;
    nRes = n1.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link Expression} node, whose child is the following :
   * <p>
   * f0 -> AdditiveExpression()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Expression n, final A argu) {
    R nRes = null;
    // f0 -> AdditiveExpression()
    final AdditiveExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * f0 -> MultiplicativeExpression()<br>
   * f1 -> ( #0 ( %0 "+"<br>
   * .. .. . .. | %1 "-" )<br>
   * .. .. . #1 MultiplicativeExpression() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final AdditiveExpression n, final A argu) {
    R nRes = null;
    // f0 -> MultiplicativeExpression()
    final MultiplicativeExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ( #0 ( %0 "+"
    // .. .. . .. | %1 "-" )
    // .. .. . #1 MultiplicativeExpression() )*
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode nloeai = n1.elementAt(i);
        final NodeSequence seq = (NodeSequence) nloeai;
        // #0 ( %0 "+"
        // .. | %1 "-" )
        final INode seq1 = seq.elementAt(0);
        final NodeChoice nch = (NodeChoice) seq1;
        final INode ich = nch.choice;
        switch (nch.which) {
          case 0:
            // %0 "+"
            nRes = ich.accept(this, argu);
            break;
          case 1:
            // %1 "-"
            nRes = ich.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #1 MultiplicativeExpression()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link MultiplicativeExpression} node, whose children are the following :
   * <p>
   * f0 -> UnaryExpression()<br>
   * f1 -> ( #0 ( %0 "*"<br>
   * .. .. . .. | %1 "/"<br>
   * .. .. . .. | %2 "%" )<br>
   * .. .. . #1 UnaryExpression() )*<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MultiplicativeExpression n, final A argu) {
    R nRes = null;
    // f0 -> UnaryExpression()
    final UnaryExpression n0 = n.f0;
    nRes = n0.accept(this, argu);
    // f1 -> ( #0 ( %0 "*"
    // .. .. . .. | %1 "/"
    // .. .. . .. | %2 "%" )
    // .. .. . #1 UnaryExpression() )*
    final NodeListOptional n1 = n.f1;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode nloeai = n1.elementAt(i);
        final NodeSequence seq = (NodeSequence) nloeai;
        // #0 ( %0 "*"
        // .. | %1 "/"
        // .. | %2 "%" )
        final INode seq1 = seq.elementAt(0);
        final NodeChoice nch = (NodeChoice) seq1;
        final INode ich = nch.choice;
        switch (nch.which) {
          case 0:
            // %0 "*"
            nRes = ich.accept(this, argu);
            break;
          case 1:
            // %1 "/"
            nRes = ich.accept(this, argu);
            break;
          case 2:
            // %2 "%"
            nRes = ich.accept(this, argu);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #1 UnaryExpression()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link UnaryExpression} node, whose child is the following :
   * <p>
   * f0 -> . %0 #0 "(" #1 Expression() #2 ")"<br>
   * .. .. | %1 Identifier()<br>
   * .. .. | %2 MyInteger()<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final UnaryExpression n, final A argu) {
    R nRes = null;
    // f0 -> . %0 #0 "(" #1 Expression() #2 ")"
    // .. .. | %1 Identifier()
    // .. .. | %2 MyInteger()
    final NodeChoice nch = n.f0;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        // %0 #0 "(" #1 Expression() #2 ")"
        final NodeSequence seq = (NodeSequence) ich;
        // #0 "("
        final INode seq1 = seq.elementAt(0);
        nRes = seq1.accept(this, argu);
        // #1 Expression()
        final INode seq2 = seq.elementAt(1);
        nRes = seq2.accept(this, argu);
        // #2 ")"
        final INode seq3 = seq.elementAt(2);
        nRes = seq3.accept(this, argu);
        break;
      case 1:
        // %1 Identifier()
        nRes = ich.accept(this, argu);
        break;
      case 2:
        // %2 MyInteger()
        nRes = ich.accept(this, argu);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link Identifier} node, whose child is the following :
   * <p>
   * f0 -> <IDENTIFIER><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final Identifier n, final A argu) {
    R nRes = null;
    // f0 -> <IDENTIFIER>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

  /**
   * Visits a {@link MyInteger} node, whose child is the following :
   * <p>
   * f0 -> <INTEGER_LITERAL><br>
   *
   * @param n - the node to visit
   * @param argu - the user argument
   * @return the user return information
   */
  @Override
  public R visit(final MyInteger n, final A argu) {
    R nRes = null;
    // f0 -> <INTEGER_LITERAL>
    final NodeToken n0 = n.f0;
    nRes = n0.accept(this, argu);
    return nRes;
  }

}
