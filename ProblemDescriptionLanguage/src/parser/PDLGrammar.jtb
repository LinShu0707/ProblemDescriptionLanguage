/**
 * JTB template file created by SF JavaCC plugin 1.5.28+ wizard for JTB 1.4.0.2+ and JavaCC 1.5.0+
 */options{  static = true;  JTB_P = "parser";}PARSER_BEGIN(PDLGrammar)package parser;import parser.visitor.*;import java.io.FileInputStream;import java.io.File;public class PDLGrammar{  public static void main(String args [])  {    try    {      new PDLGrammar(new FileInputStream(new File("testcase/a.pdl")));      Start start = PDLGrammar.Start();      DepthFirstVoidVisitor v = new MyVisitor();      start.accept(v);      System.out.println("Parse OK!");    }    catch (Exception e)    {      System.out.println("Parse Error!");      System.out.println(e.getMessage());    }  }}class MyVisitor extends DepthFirstVoidVisitor{  public void visit(NodeToken n)  {    System.out.println("visit " + n.tokenImage);  }}PARSER_END(PDLGrammar)SKIP :{  " "| "\t"| "\r"| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* KEYWORDS */{  < INPUT : "input" >| < REQUIRED : "required" >| < OUTPUT : "output" >| < INT : "int" >| < REAL : "real" >| < BOOL : "bool" >| < CHAR : "char" >| < STRING : "string" >| < TRUE : "true" >| < FALSE : "false" >}TOKEN : /* EOL */{  < EOL :    (      "\n"    | "//" (~[ "\n", "\r" ])*      (        "\n"      | "\r"      | "\r\n"      )    )+ >}TOKEN : /* LITERALS */{  < LITERAL :    < INT_LITERAL >  | < REAL_LITERAL >  | < BOOL_LITERAL >  | < CHAR_LITERAL >  | < STRING_LITERAL >>| < INT_LITERAL :    < DECIMAL_LITERAL >  | < HEX_LITERAL >  | < OCTAL_LITERAL >>| < REAL_LITERAL :    < FIXED_LITERAL >    (      [ "e", "E" ] ([ "+", "-" ])? < DECIMAL_LITERAL >    )? >| < BOOL_LITERAL :    < TRUE >  | < FALSE >>| < CHAR_LITERAL :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )    "'" >| < STRING_LITERAL : "\"" (< CHAR_LITERAL >)* "\"" >| < #FIXED_LITERAL :    < DECIMAL_LITERAL >    (      "." ([ "0"-"9" ])*    )? >| < #DECIMAL_LITERAL :    "0"  | [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "_", "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}void Start() :{}{  InputSection() RequiredSection() OutputSection() < EOF >}void InputSection() :{}{  < INPUT > < EOL >  (    InputVarDef()  )*}void RequiredSection() :{}{  < REQUIRED > < EOL >  (    RequiredCond()  )*}void OutputSection() :{}{  < OUTPUT > < EOL >  (    OutputExp()  )*}void InputVarDef() :{}{  < IDENTIFIER > [ TypeDef() ] < EOL >}void RequiredCond() :{}{  (    < IDENTIFIER > TypeDef()  | Expression()  )  < EOL >}void OutputExp() :{}{  Expression() < EOL >}void TypeDef() :{}{  ":"  (    < INT >  | < REAL >  | < BOOL >  | < CHAR >  | < STRING >  )  [    "[" [ Expression() "~" Expression() ] "]"  ]  [ RangeDef() ]| RangeDef()}void RangeDef() :{}{  (    "("  | "["  )  Expression() "," Expression()  (    ")"  | "]"  )}void Expression() :{}{  < IDENTIFIER >| < LITERAL >}